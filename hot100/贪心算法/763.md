划分片段：

    使用两个变量 start 和 end 来表示当前片段的起点和终点。
    然后再次遍历字符串，对于每个字符，更新当前片段的终点 end 为该字符最后出现位置的最大值（即 end = max(end, last[s[i] - 'a'])）。这样可以保证当前片段中的所有字符都不会在后面的部分出现。

第一个片段 "ababcbaca" :

从第一个字符 a 开始，end 被更新为 8（因为 a 最后出现的位置是 8）。
继续遍历直到索引 8，发现 end == i，这意味着从索引 0 到 8 的所有字符都可以作为一个独立的片段，因此将 9 加入 ans 中，并开始下一个片段。

第二个片段 "defegde"：

    起点：在第一个片段 "ababcbaca" 结束后，新的起点 start 为 9，对应字符 d。
    终点：算法会继续向右遍历，更新 end 为当前字符的最后出现位置的最大值：
        对于 d，它最后一次出现在索引 14，所以 end 更新为 14。
        对于 e，它最后一次出现在索引 15，所以 end 更新为 15。
        对于 f，它最后一次出现在索引 11，end 保持为 15，因为 end 取的是最大值。
        对于 g，它最后一次出现在索引 13，end 仍然保持为 15。
    当遍历到索引 15 时，end == i，表明片段 "defegde" 从索引 9 到 15 完成。此时片段长度为 15 - 9 + 1 = 7。

第三个片段 "hijhklij"：

    起点：start 更新为 16，对应字符 h。
    终点：继续遍历，更新 end：
        对于 h，最后一次出现在索引 19，所以 end 更新为 19。
        对于 i，最后一次出现在索引 22，所以 end 更新为 22。
        对于 j，最后一次出现在索引 23，所以 end 更新为 23。
        对于 k 和 l，它们的最后位置在 end 之前，所以 end 保持为 23。
    当遍历到索引 23 时，end == i，表明片段 "hijhklij" 从索引 16 到 23 完成，片段长度为 23 - 16 + 1 = 8。

最终结果：

    因此，这三个片段的长度分别是 [9, 7, 8]。